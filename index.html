<html>
<head>
	<title>Game 13KB</title>
	<style>
		* {
			margin: 0;
			user-select: none;
		}

		#space {
			background-color: black;
			height: 100%;
			width: 100%;
		}

		p {
			position: absolute;
			font-size: 30px;
			font-weight: bold;
			font-family: Verdana;
			margin: 20px;
			padding: 10px;
			border-radius: 7px;
			color: rgb(220, 220, 220);
			background: rgb(128, 128, 128);
			opacity: 0.4;
		}

		#anchor {
			bottom: 0;
			left: 0;
		}

		#rotate_sail {
			right: 0;
			top: 0;
		}

		#enable_sail {
			bottom: 0;
			right: 0;
		}

		#turn {
			left: 0;
			top: 0;
		}

		#centreboat {
			top: 50%;
			left: 0;
			transform: translateY(-50%);
		}
	</style>
</head>

<body>
	<canvas id="space"></canvas>
	<p id="anchor">&#10094;Q&#10095; &#9967;</p>
	<p id="rotate_sail">&#10227; &#10094;&#129106;&#10095;<br>&#10226; &#10094;&#129104;&#10095;</p>
	<p id="enable_sail">&#9654; &#10094;E&#10095;</p>
	<p id="turn">&#10094;A&#10095; &#8630;<br>&#10094;D&#10095; &#8631;</p>
	<p id="centreboat">&#10094;W&#10095; &#9724;</p>

	<script>
		const gl = space.getContext("webgl")
		if (!gl) throw new Error("Could not initialie WebGL")

		gl.clearColor(0, 0, 0, 1)
		gl.clearDepth(1)
		gl.enable(gl.DEPTH_TEST)
		gl.depthFunc(gl.LEQUAL)
		gl.disable(gl.BLEND)

		class Mesh {
			constructor(trianglesColor, linesColor, ...vertices) {
				this.model = new Model()
				this.children = []

				const lines = calculateLines(vertices)
				this.linesColor = linesColor
				this.linesLength = lines.length / 3
				this.trianglesColor = trianglesColor
				this.trianglesLength = vertices.length / 3
				this.trianglesBuffer = createArrayBuffer(vertices)
				this.linesBuffer = createArrayBuffer(lines)
			}

			render(properties, parentModel, linesOnly) {
				const model = this.model.total().MxM(parentModel)
				this.children.forEach(it => it.render(properties, model))
				gl.uniformMatrix4fv(properties.uModel, false, model)

				properties.aPosition.set(this.trianglesBuffer, 3)
				gl.uniform1f(properties.uForward, 0.0)
				gl.uniform3f(properties.uColor, this.trianglesColor[0], this.trianglesColor[1], this.trianglesColor[2])
				gl.drawArrays(gl.TRIANGLES, 0, this.trianglesLength)
				
				properties.aPosition.set(this.linesBuffer, 3)
				gl.uniform1f(properties.uForward, 0.001)
				gl.uniform3f(properties.uColor, this.linesColor[0], this.linesColor[1], this.linesColor[2])
				gl.drawArrays(gl.LINES, 0, this.linesLength)
			}
		}

		class Attribute {
			constructor(program, name) {
				this.attrib = gl.getAttribLocation(program, name)
			}

			set(buffer, size) {
				gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
				gl.vertexAttribPointer(this.attrib, size, gl.FLOAT, false, 0, 0)
				return this
			}

			enable() {
				gl.enableVertexAttribArray(this.attrib)
				return this
			}

			disable() {
				gl.disableVertexAttribArray(this.attrib)
				return this
			}
		}

		class Model {
			constructor() {
				this.translation = { x: 0, y: 0, z: 0 }
				this.rotation = { y: 0, x: 0, z: 0 }
				this.offset = { x: 0, y: 0, z: 0 }
				this.scale = { x: 1, y: 1, z: 1 }
			}

			total() {
				return scale(this.scale.x, this.scale.y, this.scale.z)
						.MxM(translate(this.offset.x, this.offset.y, this.offset.z))
						.MxM(rotate(this.rotation.y, this.rotation.x, this.rotation.z))
						.MxM(translate(this.translation.x, this.translation.y, this.translation.z))
			}

			inverse() {
				return translate(-this.translation.x, -this.translation.y, -this.translation.z)
						.MxM(rotate(-this.rotation.y, -this.rotation.x, -this.rotation.z, true))
						.MxM(translate(-this.offset.x, -this.offset.y, -this.offset.z))
						.MxM(scale(1 / this.scale.x, 1 / this.scale.y, 1 / this.scale.z))
			}
		}

		Array.prototype.MxM = function(m) {
			const out = new Array(16)
			for (let i = 0; i < 4; i++)
				for (let j = 0; j < 4; j++) {
					out[j * 4 + i] = 0
					for (let k = 0; k < 4; k++)
						out[j * 4 + i] += m[i + k * 4] * this[j * 4 + k]
				}
			return out
		}

		Array.prototype.VxM = function(m) {
			return [
				m[0] * this[0] + m[4] * this[1] +  m[8] * this[2] + m[12] * this[3],
				m[1] * this[0] + m[5] * this[1] +  m[9] * this[2] + m[13] * this[3],
				m[2] * this[0] + m[6] * this[1] + m[10] * this[2] + m[14] * this[3],
				m[3] * this[0] + m[7] * this[1] + m[11] * this[2] + m[15] * this[3]
			]
		}

		Array.prototype.VxV = function(v) {
			return [
				this[2] * v[1] - this[1] * v[2],
				this[0] * v[2] - this[2] * v[0],
				this[1] * v[0] - this[0] * v[1],
				0
			]
		}

		Array.prototype.VminusV = function(v) {
			return [ this[0] - v[0], this[1] - v[1], this[2] - v[2] ]
		}

		function mat(x = 0, y = 0, z = 0, a = 1, b = 1, c = 1, d = 0, e = 1) {
			return [
				a, 0, 0, 0,
				0, b, 0, 0,
				0, 0, c, d,
				x, y, z, e
			]
		}

		const translate = (x, y, z) => mat(x, y, z)
		const scale = (x, y, z) => mat(0, 0, 0, x, y, z)
		const ortho = (aspect, distance) => mat(0, 0, 0, 1 / aspect, 1, 1 / distance)
		const deg = angle => angle * Math.PI / 180

		function perspective(y, a, n, f) {
			const c = (f + n) / (f - n)
			const b = 2 * f * n / (n - f)
			const h = 1 / Math.tan(y / 2)
			const w = h / a
			return mat(0, 0, b, w, h, c, 1, 0)
		}

		function rotate(dy, dx, dz, inverse) {
			const rotY = [
				Math.cos(dy), 0, -Math.sin(dy), 0,
				0,            1, 0,             0,
				Math.sin(dy), 0, Math.cos(dy),  0,
				0,            0, 0,             1,
			]
			const rotX = [
				1, 0,             0,            0,
				0, Math.cos(dx),  Math.sin(dx), 0,
				0, -Math.sin(dx), Math.cos(dx), 0,
				0, 0,             0,            1
			]
			const rotZ = [
				Math.cos(dz),  Math.sin(dz), 0, 0,
				-Math.sin(dz), Math.cos(dz), 0, 0,
				0,             0,            1, 0,
				0,             0,            0, 1,
			]
			return inverse ? rotY.MxM(rotX).MxM(rotZ) : rotZ.MxM(rotX).MxM(rotY)
		}

		function compile(type, source) {
			let shader = gl.createShader(type)
			gl.shaderSource(shader, source)
			gl.compileShader(shader)

			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				console.error("ShaderProgram: could not compile " +
					(type == gl.VERTEX_SHADER ? "vertex" : "fragment") + "shader")
				console.error(gl.getShaderInfoLog(shader))
				shader = 0
			}

			return shader
		}

		function link(vertex, fragment) {
			let program = gl.createProgram()
			gl.attachShader(program, fragment)
			gl.attachShader(program, vertex)
			gl.linkProgram(program)

			 if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
				console.error("ShaderProgram: could not link program")
				console.error(gl.getProgramInfoLog(program))
				program = 0
			}

			return program
		}

		function createArrayBuffer(data) {
			const buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
			gl.bindBuffer(gl.ARRAY_BUFFER, null)
			return buffer
		}

		function modifyArrayBuffer(buffer, anchors, data) {
			const data32 = new Float32Array(data)
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			for (let i = 0; i < anchors.length; i++) {
				gl.bufferSubData(gl.ARRAY_BUFFER, anchors[i] * 3 * 4, data32)
			}
			gl.bindBuffer(gl.ARRAY_BUFFER, null)
			return buffer
		}

		function extract(data, index, size) {
			const out = []
			for (let i = 0; i < size; i++)
				out.push(data[index + i])
			return out
		}

		function append(target, data, size) {
			for (let i = 0; i < size; i++)
				target.push(data[i])
		}

		function cache(container, target, a, b) {
			const pa = a.join(',')
			const pb = b.join(',')
			const ab = pa + ':' + pb
			const ba = pb + ':' + pa
			if (!container[ab] && !container[ba]) {
				container[ab] = container[ba] = true
				append(target, a, 3)
				append(target, b, 3)
			}
		}

		function calculateLines(vertices) {
			const found = {}
			const lines = []
			for (let i = 0; i < vertices.length; i += 9) {
				const a = extract(vertices, i, 3)
				const b = extract(vertices, i + 3, 3)
				const c = extract(vertices, i + 6, 3)				
				cache(found, lines, a, b)
				cache(found, lines, b, c)
				cache(found, lines, a, c)
			}
			return lines
		}

		function range(lower, target, higher) {
			if (target < lower) return lower
			if (target > higher) return higher
			return target
		}

		const MESH_VERTEX_SHADER = compile(gl.VERTEX_SHADER, `
			precision lowp float;
			attribute vec3 aPosition;
			uniform mat4 uModel;
			uniform mat4 uView;
			uniform mat4 uProjection;
			uniform float uForward;

			void main(void) {
				gl_Position = uProjection * uView * uModel * vec4(aPosition, 1.0);
				gl_Position.z -= uForward;
			}
		`)

		const WATER_VERTEX_SHADER = compile(gl.VERTEX_SHADER, `
			precision lowp float;
			attribute vec3 aPosition;
			uniform mat4 uModel;
			uniform mat4 uView;
			uniform mat4 uProjection;
			uniform float uForward;
			uniform float uState;

			float distortion(vec3 p) {
				float wave = 5.0;
				float x = (p.x / wave + uState) * 2.0 * 3.14;
				float z = (p.z / wave + uState) * 2.0 * 3.14;
				return 0.5 * (sin(x) + cos(z));
			}

			void main(void) {
				vec4 globalPosition = uModel * vec4(aPosition, 1.0);
				globalPosition.y += 0.1 * distortion(globalPosition.xyz);
				gl_Position = uProjection * uView * globalPosition;
				gl_Position.z -= uForward;
			}
		`)

		const FRAGMENT_SHADER = compile(gl.FRAGMENT_SHADER, `
			precision lowp float;
			uniform vec3 uColor;

			void main(void) {
				gl_FragColor = vec4(uColor, 1.0);
			}
		`)

		const MESH_PROGRAM = link(MESH_VERTEX_SHADER, FRAGMENT_SHADER)
		const MESH_PROGRAM_PROPERTIES = {}
		MESH_PROGRAM_PROPERTIES.aPosition = new Attribute(MESH_PROGRAM, "aPosition").enable()
		MESH_PROGRAM_PROPERTIES.uColor = gl.getUniformLocation(MESH_PROGRAM, "uColor")
		MESH_PROGRAM_PROPERTIES.uModel = gl.getUniformLocation(MESH_PROGRAM, "uModel")
		MESH_PROGRAM_PROPERTIES.uView = gl.getUniformLocation(MESH_PROGRAM, "uView")
		MESH_PROGRAM_PROPERTIES.uProjection = gl.getUniformLocation(MESH_PROGRAM, "uProjection")
		MESH_PROGRAM_PROPERTIES.uForward = gl.getUniformLocation(MESH_PROGRAM, "uForward")

		const WATER_PROGRAM = link(WATER_VERTEX_SHADER, FRAGMENT_SHADER)
		const WATER_PROGRAM_PROPERTIES = {}
		WATER_PROGRAM_PROPERTIES.aPosition = new Attribute(WATER_PROGRAM, "aPosition").enable()
		WATER_PROGRAM_PROPERTIES.uColor = gl.getUniformLocation(WATER_PROGRAM, "uColor")
		WATER_PROGRAM_PROPERTIES.uModel = gl.getUniformLocation(WATER_PROGRAM, "uModel")
		WATER_PROGRAM_PROPERTIES.uView = gl.getUniformLocation(WATER_PROGRAM, "uView")
		WATER_PROGRAM_PROPERTIES.uProjection = gl.getUniformLocation(WATER_PROGRAM, "uProjection")
		WATER_PROGRAM_PROPERTIES.uForward = gl.getUniformLocation(WATER_PROGRAM, "uForward")
		WATER_PROGRAM_PROPERTIES.uState = gl.getUniformLocation(WATER_PROGRAM, "uState")

		const CAMERA = new Model()
		CAMERA.rotation.x = deg(10)
		CAMERA.offset.z = -2
		CAMERA.offset.y = 0.5

		document.addEventListener('mousedown', e => {
			CAMERA.isMoving = true
			CAMERA.oldX = CAMERA.rotation.x + e.y / 500
			CAMERA.oldY = CAMERA.rotation.y + e.x / 500
		})

		document.addEventListener('mousemove', e => {
			if (CAMERA.isMoving) {
				CAMERA.rotation.y = CAMERA.oldY - e.x / 500
				CAMERA.rotation.x = range(deg(10), CAMERA.oldX - e.y / 500, deg(90))
			}
		})

		document.addEventListener('mouseup', e => {
			CAMERA.isMoving = false
		})

		document.addEventListener('wheel', e => {
			CAMERA.offset.z = range(-10, CAMERA.offset.z - e.deltaY / 100, -2)
		})

		const KEYS = []

		document.addEventListener('keydown', e => {
			KEYS[e.key] = true
		})

		document.addEventListener('keyup', e => {
			KEYS[e.key] = false
		})

		const WORLD = []
		const WATER = []
		const UPDATES = []
		WORLD.time = new Date().getTime()

		const WATER_TRIANGLES_COLOR = [0.6, 0.6, 1]
		const WATER_LINES_COLOR = [0.4, 0.4, 0.7]
		const CHUNK_VERTICES = [
			-2, 0,   0,
			 0, 0,   0,
			-1, 0, 1.7,
			 0, 0,   0,
			 2, 0,   0,
			 1, 0, 1.7,
			-1, 0, 1.7,
			 1, 0, 1.7,
			 0, 0, 3.4,
			 0, 0,   0,
			 1, 0, 1.7,
			-1, 0, 1.7,
		]

		// const rect = new Mesh([1, 1, 1], [0, 1, 1],
		// 	-0.5, -0.5, 0,
		// 	 0.5,  0.5, 0,
		// 	-0.5,  0.5, 0,
		// 	-0.5, -0.5, 0,
		// 	 0.5, -0.5, 0,
		// 	 0.5,  0.5, 0,
		// )
		// rect.model.rotation.x = deg(90)
		// WORLD.push(rect)

		const BOAT_BODY = new Mesh([0.6, 0.5, 0.4], [0.5, 0.4, 0.3],
			0.0, -0.9, -2.6,
			0.0, 1.0, -3.4,
			-1.6, 1.0, 0.0,
			0.0, 0.9, 0.0,
			0.0, 1.0, 3.4,
			-1.6, 1.0, 0.0,
			0.0, 1.0, -3.4,
			0.0, 0.9, 0.0,
			-1.6, 1.0, 0.0,
			0.0, -0.9, -2.6,
			-1.6, 1.0, 0.0,
			0.0, -0.9, 0.0,
			-1.6, 1.0, 0.0,
			0.0, 1.0, 3.4,
			0.0, -0.9, 2.6,
			0.0, -0.9, 0.0,
			-1.6, 1.0, 0.0,
			0.0, -0.9, 2.6,
			0.0, -0.9, -2.6,
			1.6, 1.0, 0.0,
			0.0, 1.0, -3.4,
			0.0, 0.9, 0.0,
			1.6, 1.0, 0.0,
			0.0, 1.0, 3.4,
			0.0, 1.0, -3.4,
			1.6, 1.0, 0.0,
			0.0, 0.9, 0.0,
			0.0, -0.9, -2.6,
			0.0, -0.9, 0.0,
			1.6, 1.0, 0.0,
			1.6, 1.0, 0.0,
			0.0, -0.9, 2.6,
			0.0, 1.0, 3.4,
			0.0, -0.9, 0.0,
			0.0, -0.9, 2.6,
			1.6, 1.0, 0.0,
		)
		CAMERA.translation = BOAT_BODY.model.translation
		BOAT_BODY.model.translation.z = 1.5
		BOAT_BODY.model.scale.x = 0.25
		BOAT_BODY.model.scale.y = 0.25
		BOAT_BODY.model.scale.z = 0.25
		WORLD.push(BOAT_BODY)

		const BOAT_MAST = new Mesh([0.6, 0.5, 0.4], [0.5, 0.4, 0.3],
			0.1, 6.0, 0.0,
			0.1, 0.9, 0.0,
			0.0, 0.9, 0.1,
			0.0, 6.0, 0.1,
			0.0, 0.9, 0.1,
			-0.1, 0.9, 0.0,
			-0.1, 6.0, 0.0,
			-0.1, 0.9, 0.0,
			0.0, 0.9, -0.1,
			0.0, 6.0, -0.1,
			0.0, 0.9, -0.1,
			0.1, 0.9, 0.0,
			-0.1, 0.9, 0.0,
			0.0, 0.9, 0.1,
			0.1, 0.9, 0.0,
			0.0, 6.0, 0.1,
			-0.1, 6.0, 0.0,
			0.0, 6.0, -0.1,
			0.1, 6.0, 0.0,
			0.0, 0.9, 0.1,
			0.0, 6.0, 0.1,
			0.0, 6.0, 0.1,
			-0.1, 0.9, 0.0,
			-0.1, 6.0, 0.0,
			-0.1, 6.0, 0.0,
			0.0, 0.9, -0.1,
			0.0, 6.0, -0.1,
			0.0, 6.0, -0.1,
			0.1, 0.9, 0.0,
			0.1, 6.0, 0.0,
			-0.1, 0.9, 0.0,
			0.1, 0.9, 0.0,
			0.0, 0.9, -0.1,
			0.0, 6.0, 0.1,
			0.0, 6.0, -0.1,
			0.1, 6.0, 0.0,
			0.1, 1.3, 0.0,
			0.1, 1.3, 3.9,
			0.0, 1.4, 3.9,
			0.0, 1.4, 0.0,
			0.0, 1.4, 3.9,
			-0.1, 1.3, 3.9,
			-0.1, 1.3, 0.0,
			-0.1, 1.3, 3.9,
			0.0, 1.2, 3.9,
			0.0, 1.2, 0.0,
			0.0, 1.2, 3.9,
			0.1, 1.3, 3.9,
			-0.1, 1.3, 3.9,
			0.0, 1.4, 3.9,
			0.1, 1.3, 3.9,
			0.0, 1.4, 0.0,
			-0.1, 1.3, 0.0,
			0.0, 1.2, 0.0,
			0.1, 1.3, 0.0,
			0.0, 1.4, 3.9,
			0.0, 1.4, 0.0,
			0.0, 1.4, 0.0,
			-0.1, 1.3, 3.9,
			-0.1, 1.3, 0.0,
			-0.1, 1.3, 0.0,
			0.0, 1.2, 3.9,
			0.0, 1.2, 0.0,
			0.0, 1.2, 0.0,
			0.1, 1.3, 3.9,
			0.1, 1.3, 0.0,
			-0.1, 1.3, 3.9,
			0.1, 1.3, 3.9,
			0.0, 1.2, 3.9,
			0.0, 1.4, 0.0,
			0.0, 1.2, 0.0,
			0.1, 1.3, 0.0,
		)
		BOAT_BODY.children.push(BOAT_MAST)
		BOAT_MAST.model.rotation.y = Math.PI

		const BOAT_SAIL = new Mesh([1, 1, 1], [0, 0, 0],
			-0.1, 2.3, 1.5,
			0.0, 1.4, 0.1,
			0.0, 6.0, 0.1,
			0.0, 1.4, 0.1,
			-0.1, 2.3, 1.5,
			0.0, 1.4, 3.9,
			-0.1, 2.3, 1.5,
			0.0, 6.0, 0.1,
			0.0, 1.4, 3.9,
		)
		BOAT_MAST.children.push(BOAT_SAIL)
		const BOAT_SAIL_TRIANGLES = [0, 4, 6]
		const BOAT_SAIL_LINES = [0, 4, 6]


		let flip = false
		for (let k = -3; k < 4; k++) {
			for (let i = -5; i < 6; i++) {
				const WATER_CHUNK = new Mesh(WATER_TRIANGLES_COLOR, WATER_LINES_COLOR, ...CHUNK_VERTICES)
				WATER_CHUNK.model.rotation.y = flip ? 0 : Math.PI;
				WATER_CHUNK.model.translation.z = (flip ? 0 : 3.4) + 3.4 * k
				WATER_CHUNK.model.translation.x = i * 2
				WATER.push(WATER_CHUNK)
				flip = !flip
			}
		}


		requestAnimationFrame(function render() {
			const newTime = new Date().getTime()
			WORLD.dt = newTime - WORLD.time
			WORLD.time = newTime
			UPDATES.forEach(it => it())

			space.width = space.clientWidth
			space.height = space.clientHeight
			gl.viewport(0, 0, space.clientWidth, space.clientHeight)
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			gl.useProgram(MESH_PROGRAM)
			const projection = perspective(deg(90), space.clientWidth / space.clientHeight, 0.1, 100)
			// const projection = scale(0.3, 0.3, 1).MxM(ortho(space.clientWidth / space.clientHeight, 100))
			gl.uniformMatrix4fv(MESH_PROGRAM_PROPERTIES.uProjection, false, projection)
			gl.uniformMatrix4fv(MESH_PROGRAM_PROPERTIES.uView, false, CAMERA.inverse())
			
			const empty = mat()
			WORLD.forEach(it => it.render(MESH_PROGRAM_PROPERTIES, empty))

			gl.useProgram(WATER_PROGRAM)
			gl.uniformMatrix4fv(WATER_PROGRAM_PROPERTIES.uProjection, false, projection)
			gl.uniformMatrix4fv(WATER_PROGRAM_PROPERTIES.uView, false, CAMERA.inverse())
			gl.uniform1f(WATER_PROGRAM_PROPERTIES.uState, WORLD.time % 2000 / 2000)

			WATER.forEach(it => it.render(WATER_PROGRAM_PROPERTIES, empty))

			requestAnimationFrame(render)
		})

		UPDATES.push(() => {
			const sail = Math.sin(WORLD.time % 3000 / 1500 * Math.PI)

			modifyArrayBuffer(BOAT_SAIL.trianglesBuffer, BOAT_SAIL_TRIANGLES, [-0.1 + sail, 2.3, 1.5])
			modifyArrayBuffer(BOAT_SAIL.linesBuffer, BOAT_SAIL_LINES, [-0.1 + sail, 2.3, 1.5])

			const boat = Math.sin(WORLD.time % 5000 / 2500 * Math.PI)
			BOAT_BODY.model.rotation.z = boat / 10

			if (KEYS["a"])
				BOAT_BODY.model.rotation.y -= 0.001 * WORLD.dt

			if (KEYS["d"])
				BOAT_BODY.model.rotation.y += 0.001 * WORLD.dt

			if (KEYS["w"]){ //temporary
	        	BOAT_BODY.model.translation.x += 0.05 * Math.sin(BOAT_BODY.model.rotation.y)
				BOAT_BODY.model.translation.z += 0.05 * Math.cos(BOAT_BODY.model.rotation.y)
	    	}

			if (KEYS["ArrowLeft"])
				BOAT_MAST.model.rotation.y = Math.min(BOAT_MAST.model.rotation.y + 0.002 * WORLD.dt, 3 * Math.PI / 2)

			if (KEYS["ArrowRight"])
				BOAT_MAST.model.rotation.y = Math.max(BOAT_MAST.model.rotation.y - 0.002 * WORLD.dt, Math.PI / 2)
		})
	</script>
</body>

</html>